// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package sqlite_world_repo

import (
	"context"
)

const deleteWorldChunk = `-- name: DeleteWorldChunk :exec
DELETE FROM world_chunk
WHERE world_id = ? AND row_id = ? AND col_id = ?
`

type DeleteWorldChunkParams struct {
	WorldID int64
	RowID   int64
	ColID   int64
}

func (q *Queries) DeleteWorldChunk(ctx context.Context, arg DeleteWorldChunkParams) error {
	_, err := q.db.ExecContext(ctx, deleteWorldChunk, arg.WorldID, arg.RowID, arg.ColID)
	return err
}

const getWorld = `-- name: GetWorld :one
SELECT world_id, date_created, row_length, column_length, chunk_length
FROM world
WHERE world_id = ?
`

func (q *Queries) GetWorld(ctx context.Context, worldID int64) (World, error) {
	row := q.db.QueryRowContext(ctx, getWorld, worldID)
	var i World
	err := row.Scan(
		&i.WorldID,
		&i.DateCreated,
		&i.RowLength,
		&i.ColumnLength,
		&i.ChunkLength,
	)
	return i, err
}

const getWorldChunk = `-- name: GetWorldChunk :one
SELECT world_id, row_id, col_id, last_updated, locked, chunk
FROM world_chunk
WHERE world_id = ? AND row_id = ? AND col_id = ?
`

type GetWorldChunkParams struct {
	WorldID int64
	RowID   int64
	ColID   int64
}

func (q *Queries) GetWorldChunk(ctx context.Context, arg GetWorldChunkParams) (WorldChunk, error) {
	row := q.db.QueryRowContext(ctx, getWorldChunk, arg.WorldID, arg.RowID, arg.ColID)
	var i WorldChunk
	err := row.Scan(
		&i.WorldID,
		&i.RowID,
		&i.ColID,
		&i.LastUpdated,
		&i.Locked,
		&i.Chunk,
	)
	return i, err
}

const getWorldChunkByWorldId = `-- name: GetWorldChunkByWorldId :many
SELECT world_id, row_id, col_id, last_updated, locked, chunk
FROM world_chunk
WHERE world_id = ?
ORDER BY row_id, col_id
`

func (q *Queries) GetWorldChunkByWorldId(ctx context.Context, worldID int64) ([]WorldChunk, error) {
	rows, err := q.db.QueryContext(ctx, getWorldChunkByWorldId, worldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorldChunk
	for rows.Next() {
		var i WorldChunk
		if err := rows.Scan(
			&i.WorldID,
			&i.RowID,
			&i.ColID,
			&i.LastUpdated,
			&i.Locked,
			&i.Chunk,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWorld = `-- name: InsertWorld :execlastid
INSERT INTO world (row_length, column_length, chunk_length)
VALUES (?, ?, ?)
`

type InsertWorldParams struct {
	RowLength    int64
	ColumnLength int64
	ChunkLength  int64
}

func (q *Queries) InsertWorld(ctx context.Context, arg InsertWorldParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWorld, arg.RowLength, arg.ColumnLength, arg.ChunkLength)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const insertWorldChunk = `-- name: InsertWorldChunk :execlastid
INSERT INTO world_chunk (world_id, row_id, col_id, locked, chunk)
VALUES (?, ?, ?, ?, ?)
`

type InsertWorldChunkParams struct {
	WorldID int64
	RowID   int64
	ColID   int64
	Locked  bool
	Chunk   []byte
}

func (q *Queries) InsertWorldChunk(ctx context.Context, arg InsertWorldChunkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, insertWorldChunk,
		arg.WorldID,
		arg.RowID,
		arg.ColID,
		arg.Locked,
		arg.Chunk,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const updateWorld = `-- name: UpdateWorld :exec
UPDATE world
SET row_length = ?, column_length = ?, chunk_length = ?
WHERE world_id = ?
`

type UpdateWorldParams struct {
	RowLength    int64
	ColumnLength int64
	ChunkLength  int64
	WorldID      int64
}

func (q *Queries) UpdateWorld(ctx context.Context, arg UpdateWorldParams) error {
	_, err := q.db.ExecContext(ctx, updateWorld,
		arg.RowLength,
		arg.ColumnLength,
		arg.ChunkLength,
		arg.WorldID,
	)
	return err
}

const updateWorldChunk = `-- name: UpdateWorldChunk :exec
UPDATE world_chunk
SET last_updated = CURRENT_TIMESTAMP, locked = ?, chunk = ?
WHERE world_id = ? AND row_id = ? AND col_id = ?
`

type UpdateWorldChunkParams struct {
	Locked  bool
	Chunk   []byte
	WorldID int64
	RowID   int64
	ColID   int64
}

func (q *Queries) UpdateWorldChunk(ctx context.Context, arg UpdateWorldChunkParams) error {
	_, err := q.db.ExecContext(ctx, updateWorldChunk,
		arg.Locked,
		arg.Chunk,
		arg.WorldID,
		arg.RowID,
		arg.ColID,
	)
	return err
}
